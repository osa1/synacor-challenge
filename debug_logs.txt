After `use teleporter`, first time R8 is read is by this:

REGS:       [2708] [5445] [3] [10] [101] [0] [0] [0]
STACK:      [6080, 16, 6124, 1, 2952, 25978, 3568, 3599, 2708, 5445, 3]
IP:         5451
INSTR SIZE: 3
NEXT IP:    5454

> disas 5451 100
[5451] Jf [Reg(7), Num(5605)]
[5454] Push [Reg(0)]
[5456] Push [Reg(1)]
[5458] Push [Reg(2)]
[5460] Set [Reg(0), Num(28844)]
[5463] Set [Reg(1), Num(1531)]
[5466] Add [Reg(2), Num(10236), Num(7398)]
<<<<<< REGS:       [28844] [1531] [17634] [10] [101] [0] [0] [1]
[5470] Call [Num(1458)] -- print_string()
[5472] Pop [Reg(2)]
[5474] Pop [Reg(1)]
[5476] Pop [Reg(0)]
[5478] Noop []
[5479] Noop []
[5480] Noop []
[5481] Noop []
[5482] Noop []
...

Interestingly, even though stack has stuff in it, this doesn't look like a
function -- it restores R1, R2, and R3 but doesn't return.

5605 should be doing the usual stuff. So we should look at what 1458 is doing.

On entry R1 is 28844, R2 is 1531, R3 is 17634.

> disas 1458 100
[1458] Push [Reg(0)]
[1460] Push [Reg(3)]
[1462] Push [Reg(4)]
[1464] Push [Reg(5)]
[1466] Push [Reg(6)]
[1468] Set [Reg(6), Reg(0)]
[1471] Set [Reg(5), Reg(1)]
<<<<<< REGS:       [28844] [1531] [17634] [10] [101] [1531] [28844] [1]
[1474] Rmem [Reg(4), Reg(0)]
<<<<<< REGS:       [28844] [1531] [17634] [10] [169] [1531] [28844] [1]
[1477] Set [Reg(1), Num(0)]
[1480] Add [Reg(3), Num(1), Reg(1)]
<<<<<< REGS:       [28844] [0] [17634] [1] [169] [1531] [28844] [1]
[1484] Gt [Reg(0), Reg(3), Reg(4)] -- if (reg3 > reg4) { return; }
[1488] Jt [Reg(0), Num(1507)] ------------- jumps to 1507 (returns)
[1491] Add [Reg(3), Reg(3), Reg(6)] -- reg3 += reg6;
[1495] Rmem [Reg(0), Reg(3)] -- reg0 = *reg3;
[1498] Call [Reg(5)] ---------------------- jumps to 1531
[1500] Add [Reg(1), Reg(1), Num(1)] -- reg1 += 1;
[1504] Jt [Reg(1), Num(1480)] ------------- jumps to 1480 (loop)
[1507] Pop [Reg(6)]
[1509] Pop [Reg(5)]
[1511] Pop [Reg(4)]
[1513] Pop [Reg(3)]
[1515] Pop [Reg(0)]
[1517] Ret [] ----------------------------- end of basic block 1458

This looks like something that prints a string. Indeed, I placed a breakpoint at
1517, and when I run it just printed stuff.

At this point in prints this btw:

    A strange, electronic voice is projected into your mind:

      "Unusual setting detected!  Starting confirmation process!  Estimated time to completion: 1 billion years."

Good! Now we return to 5472. Which just restores some registers but doesn't
return! It turns out it executes instructions after NOOPs...

[5483] Set [Reg(0), Num(4)]
[5486] Set [Reg(1), Num(1)]
<<<<<< REGS:       [4] [1] [3] [10] [101] [0] [0] [1]
<<<<<< STACK:      [6080, 16, 6124, 1, 2952, 25978, 3568, 3599, 2708, 5445, 3]
[5489] Call [Num(6027)]
...

> disas 6027 100
                                         -- fn(reg0 = 4, reg1 = 1, reg7 = our value) {
[6027] Jt [Reg(0), Num(6035)]            --   if reg0 == 0 {
[6030] Add [Reg(0), Reg(1), Num(1)]      --     reg0 = reg1 + 1;
[6034] Ret []                            --     return; }
[6035] Jt [Reg(1), Num(6048)]            --   if reg1 == 0 {
[6038] Add [Reg(0), Reg(0), Num(32767)]  --     reg0 -= 1;
[6042] Set [Reg(1), Reg(7)]              --     reg1 = reg7;
[6045] Call [Num(6027)] ------ loop      --     fn();
[6047] Ret []                            --     return; }
[6048] Push [Reg(0)]                     --   push(reg0);
[6050] Add [Reg(1), Reg(1), Num(32767)]  --   reg1 -= 1;
[6054] Call [Num(6027)] ------ loop      --   fn();
[6056] Set [Reg(1), Reg(0)]              --   reg1 = reg0;
[6059] Pop [Reg(0)]                      --   reg0 = pop();
[6061] Add [Reg(0), Reg(0), Num(32767)]  --   reg0 -= 1;
[6065] Call [Num(6027)] ------ loop      --   fn();
[6067] Ret [] --end of basic block 6027  --   return;
                                         -- }

Used registers: 0, 1, 7.
Stack is also used.

I implemented this in Rust (in fn.rs). I still don't have any ideas of what this
is doing though...

!!!

At this point I started to think about some function with crazy asymptotic
complexities. I remember Ackermann and look at the Wikipedia for it. I realized
that when R8=1, this function is the Ackermann function!

Still, I don't know how to use this so I keep debugging. This function returns
to here:

[5491] Eq [Reg(1), Reg(0), Num(6)] -- reg0 has the return value
[5495] Jf [Reg(1), Num(5579)]
[5498] Push [Reg(0)]
[5500] Push [Reg(1)]
[5502] Push [Reg(2)]
[5504] Set [Reg(0), Num(29014)]
[5507] Set [Reg(1), Num(1531)]
[5510] Add [Reg(2), Num(5928), Num(17208)]
[5514] Call [Num(1458)] -- print_string()
[5516] Pop [Reg(2)]
[5518] Pop [Reg(1)]
[5520] Pop [Reg(0)]
[5522] Set [Reg(0), Reg(7)]
[5525] Set [Reg(1), Num(25866)]
[5528] Set [Reg(2), Num(32767)]
[5531] Push [Reg(3)]
[5533] Set [Reg(3), Num(29241)]
[5536] Call [Num(1841)]
[5538] Pop [Reg(3)]
[5540] Push [Reg(0)]
[5542] Push [Reg(1)]
[5544] Push [Reg(2)]
[5546] Set [Reg(0), Num(29245)]
[5549] Set [Reg(1), Num(1531)]
[5552] Add [Reg(2), Num(3250), Num(2099)]
[5556] Call [Num(1458)] -- print_string()
[5558] Pop [Reg(2)]
[5560] Pop [Reg(1)]
[5562] Pop [Reg(0)]
[5564] Wmem [Num(2732), Num(2498)]
[5567] Wmem [Num(2733), Num(0)]
[5570] Add [Reg(1), Num(2708), Num(2)]
[5574] Wmem [Reg(1), Num(32767)]
[5577] Jmp [Num(5714)]
[5579] Push [Reg(0)]
[5581] Push [Reg(1)]
[5583] Push [Reg(2)]
[5585] Set [Reg(0), Num(29400)]
[5588] Set [Reg(1), Num(1531)]
[5591] Add [Reg(2), Num(7707), Num(82)]
[5595] Call [Num(1458)] -- print_string()
[5597] Pop [Reg(2)]
[5599] Pop [Reg(1)]
[5601] Pop [Reg(0)]
[5603] Jmp [Num(5714)]
[5605] Push [Reg(0)]
[5607] Push [Reg(1)]
[5609] Push [Reg(2)]
[5611] Set [Reg(0), Num(29545)]
[5614] Set [Reg(1), Num(1531)]
[5617] Add [Reg(2), Num(11291), Num(10202)]
[5621] Call [Num(1458)] -- print_string()
[5623] Pop [Reg(2)]
[5625] Pop [Reg(1)]
[5627] Pop [Reg(0)]
[5629] Set [Reg(0), Num(0)]
[5632] Add [Reg(2), Num(1), Num(27101)]
[5636] Rmem [Reg(1), Reg(2)]
[5639] Add [Reg(0), Reg(0), Reg(1)]
[5643] Mult [Reg(0), Reg(0), Num(31660)]
[5647] Call [Num(2125)]
[5649] Rmem [Reg(1), Num(27101)]
[5652] Add [Reg(1), Reg(1), Num(27101)]
[5656] Add [Reg(2), Reg(2), Num(1)]
[5660] Gt [Reg(1), Reg(2), Reg(1)]
[5664] Jf [Reg(1), Num(5636)]
[5667] Set [Reg(1), Num(25866)]
[5670] Set [Reg(2), Num(32767)]
[5673] Push [Reg(3)]
[5675] Set [Reg(3), Num(29663)]
[5678] Call [Num(1841)]
[5680] Pop [Reg(3)]
[5682] Push [Reg(0)]
[5684] Push [Reg(1)]
[5686] Push [Reg(2)]
[5688] Set [Reg(0), Num(29667)]
[5691] Set [Reg(1), Num(1531)]
[5694] Add [Reg(2), Num(12624), Num(1175)]
[5698] Call [Num(1458)] -- print_string()
[5700] Pop [Reg(2)]
[5702] Pop [Reg(1)]
[5704] Pop [Reg(0)]
[5706] Wmem [Num(2732), Num(2488)]
[5709] Wmem [Num(2733), Num(0)]
[5712] Jmp [Num(5714)]
[5714] Pop [Reg(2)]
[5716] Pop [Reg(1)]
[5718] Pop [Reg(0)]
[5720] Ret []
